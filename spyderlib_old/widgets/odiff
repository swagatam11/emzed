diff --git a/spyderlib/widgets/objecteditor.py b/spyderlib/widgets/objecteditor.py
index e46f679..ed841ff 100644
--- a/spyderlib/widgets/objecteditor.py
+++ b/spyderlib/widgets/objecteditor.py
@@ -39,18 +39,40 @@ class DialogKeeper(QObject):
 
 keeper = DialogKeeper()
 
-def dialog_for(obj, obj_name):
-
-    """ uschmitt: this code was at the heart of oedit(). I introduced 
-        an indirection here so that i can monkey patch oedit to show msExpert 
-        related data
+def oedit(obj, modal=True, namespace=None):
     """
+    Edit the object 'obj' in a GUI-based editor and return the edited copy
+    (if Cancel is pressed, return None)
+
+    The object 'obj' is a container
     
+    Supported container types:
+    dict, list, tuple, str/unicode or numpy.array
+    
+    (instantiate a new QApplication if necessary,
+    so it can be called directly from the interpreter)
+    """
+    # Local import
     from spyderlib.widgets.texteditor import TextEditor
     from spyderlib.widgets.dicteditorutils import (ndarray, FakeObject,
                                                    Image, is_known_type)
     from spyderlib.widgets.dicteditor import DictEditor
     from spyderlib.widgets.arrayeditor import ArrayEditor
+    
+    from spyderlib.utils.qthelpers import qapplication
+    app = qapplication()
+    
+    if modal:
+        obj_name = ''
+    else:
+        assert isinstance(obj, basestring)
+        obj_name = obj
+        if namespace is None:
+            namespace = globals()
+        keeper.set_namespace(namespace)
+        obj = namespace[obj_name]
+        # keep QApplication reference alive in the Python interpreter:
+        namespace['__qapp__'] = app
 
     conv_func = lambda data: data
     readonly = not is_known_type(obj)
@@ -66,7 +88,7 @@ def dialog_for(obj, obj_name):
         data = np.array(obj)
         if not dialog.setup_and_check(data, title=obj_name,
                                       readonly=readonly):
-            return 
+            return
         import PIL.Image
         conv_func = lambda data: PIL.Image.fromarray(data, mode=obj.mode)
     elif isinstance(obj, (str, unicode)):
@@ -75,57 +97,20 @@ def dialog_for(obj, obj_name):
         dialog = DictEditor()
         dialog.setup(obj, title=obj_name, readonly=readonly)
     else:
-
         raise RuntimeError("Unsupported datatype")
-
-    return dialog, conv_func
-
-
-def oedit(obj, modal=True, namespace=None):
-    """
-    Edit the object 'obj' in a GUI-based editor and return the edited copy
-    (if Cancel is pressed, return None)
-
-    The object 'obj' is a container
-    
-    Supported container types:
-    dict, list, tuple, str/unicode or numpy.array
-    
-    (instantiate a new QApplication if necessary,
-    so it can be called directly from the interpreter)
-    """
-    # Local import
-   
     
-    from spyderlib.utils.qthelpers import qapplication
-    app = qapplication()
-    
-    if modal:
-        obj_name = ''
-    else:
-        assert isinstance(obj, basestring)
-        obj_name = obj
-        if namespace is None:
-            namespace = globals()
-        keeper.set_namespace(namespace)
-        obj = namespace[obj_name]
-
-    rv = dialog_for(obj, obj_name)
-    if rv is None:
-        return
-    dialog, conv_func = rv
-
     def end_func(dialog):
         return conv_func(dialog.get_value())
     
     if modal:
-        dialog.exec_()
-        if dialog.result():
+        if dialog.exec_():
             return end_func(dialog)
     else:
         keeper.create_dialog(dialog, obj_name, end_func)
         import os
-        if os.environ.get("REMOVE_PYQT_INPUTHOOK", "").lower() == "true" \
+        replaced_pyqt_inputhook = os.environ.get("REPLACE_PYQT_INPUTHOOK", ""
+                                                 ).lower() == "true"
+        if os.name == 'nt' and not replaced_pyqt_inputhook \
            and not os.environ.get('IPYTHON', False):
             app.exec_()
 
